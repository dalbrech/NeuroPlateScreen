////////////////////////////////////////////////////////////////////////////////////////////////
//
// Karl Bellve
// Biomedical Imaging Group
// University of Massachusetts Medical School
// Karl.Bellve@umassmed.edu
// 
// Ben Czech 
// czechben@gmail.com
//
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Modified by Ross Lagoy for use with BioVision Controller & GUI2_201802
// ross.lagoy@gmai.com
// Worcester Polytechnic Institute
// Biomedical Engineering
// 2.20.2018
//
//USES DATA GENERATED BY '01 PARAMETER INPUT GUI' to image a well //plate and provide controlled stimulus over time.
//
////////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************//
addClassPath("Big.jar");

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
import java.io.*;
import java.net.*;
import java.awt.EventQueue;

import edu.umassmed.big.SBSPlate;
import ij.gui.*;
import java.lang.Math;
import org.micromanager.api.PositionList;
import org.micromanager.api.Autofocus;
import org.micromanager.api.AcquisitionOptions;
import org.micromanager.PositionListDlg;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import ij.process.*;
import ij.ImagePlus;
import ij.io.FileSaver;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Scanner;
import net.miginfocom.swing.MigLayout;
import org.micromanager.api.AcquisitionOptions;  

////////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************//

// Center over first well, home it using HCS Plugin, and will move stage from right to left
// Apply GUIRL
// {column,row}
// 1 indexed {min 1,1}
// 1 indexed {max 12,8} or {max 24, 16}, stage moves to right {nx,j}, down {j,nx}
// could be 24, 96, 384, 1536, must conform to SBS standard

//********************************************************************************************//
////////////////////////////////////////////////////////////////////////////////////////////////

String goodguisavepath;
String settingsFilename = "H:/User Defined Acquisition Settings.txt";
SERIAL_WAIT = 1000; 		// Time to wait for serial communication (ms)

// Create Info Window
createInfoWindow( String windowName)
{
	if (f4 != void) {
		f4.dispatchEvent(new WindowEvent(f, WindowEvent.WINDOW_CLOSING));
	}
	
	f4 = new JFrame( windowName );
	f4.setBounds(200,100,200,200);
	cp4 = f4.getContentPane(); 
	cp4.setLayout(new MigLayout()); 
	f4.setSize(200, 500);
	f4.setLocation(1250, 300);
	f4.setResizable(false);
	global.textArea = new JTextArea(20, 40);
	textArea.setEditable(false);
	//SUMMARY WINDOW PRINT SETTINGS
	textArea.setText("");
	JLabel = summarylbl = new JLabel("Acquisition Status");
	summarylbl.setForeground(Color.BLACK);
	summarylbl.setFont(new Font("Serif",Font.BOLD,14));
	global.abort = new JButton("s"); // Abort does not work, changed to time temporarily
	abort.addActionListener(this);
	cp4.add(summarylbl, "gapbottom 1, span, split 2, aligny center");
	cp4.add(new JSeparator(),"gapleft rel,growx");
	cp4.add(abort);
	cp4.add(textArea);
	JScrollPane scroll = new JScrollPane (textArea, 
  		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
	cp4.add(scroll);
	f4.pack(); 
	f4.show();
	return f4;
}

// Read in text file for experiment information 
String[] readTextInfo( String filename ) 
{
	String content = new Scanner(new File(filename)).useDelimiter("\\Z").next();
	String[] extStr = content.split("\n");
	String badsavepath = new String(extStr[8]);
	goodguisavepath = badsavepath.trim();
	String content = null;
	File file = new File(settingsFilename);
	FileReader reader = new FileReader(file);
	char[] chars = new char[(int) file.length()];
	reader.read(chars);
	content = new String(chars);
	reader.close();
	
	return content.split("\n");
}

// Serial write
void serialWrite( String portName, String command) 
{
	mmc.setSerialPortCommand(portName, command, "/r");
	mmc.sleep(SERIAL_WAIT);
}

// Display info
displayInfo( String info)
{
	print(info);
	if (textArea != void) {
		textArea.append(info+"\n");
		f4.pack(); 
		f4.show();
	}
}

// Wait for next trial (ms)
void waitForNextTrial( int syswait){
			int syswaitSec = Math.floor(syswait/1000); // seconds to wait
       	mmc.sleep(syswait - syswaitSec*1000);
			displayInfo("Waiting " + syswaitSec + "s till next acquisition.");
			for(t=syswaitSec; t>0; t--) {
				mmc.sleep(1000);		
				String waitString = (t-1)+" s";
				abort.setText(waitString);	
			}		
}

void waitForNextWell( int stimulusInterval){
			int syswaitSec = Math.floor(stimulusInterval/1000); // seconds to wait
       	mmc.sleep(stimulusInterval - syswaitSec*1000);
			displayInfo("Waiting " + syswaitSec + "s till next well.");
			for(t=syswaitSec; t>0; t--) {
				mmc.sleep(1000);		
				String waitString = (t-1)+" s";
				abort.setText(waitString);	
			}		
}

void waitForNextCycle( int cycleInterval){
			int syswaitSec = Math.floor((cycleInterval*60*1000)/1000); // seconds to wait
       	mmc.sleep((cycleInterval*60*1000) - syswaitSec*1000);
			displayInfo("Waiting " + syswaitSec + "s till next cycle.");
			for(t=syswaitSec; t>0; t--) {
				mmc.sleep(1000);		
				String waitString = (t-1)+" s";
				abort.setText(waitString);	
			}		
}

// Make new directory
void mkDir(String path) {
   p = new File(path);
   if ( p.mkdirs() ) {
     gui.message("Created " + path);
     }
   else {
     gui.message("Can't make directory " + path);
     }
}

// set Filename
String setFilename( int acqCounter, int stimNumber, int cycles)
{
	 if(acqCounter>9 && acqCounter<100){
	 		movzerosa = "0";
	 } else if (acqCounter>99){
	 		movzerosa = "";
	 } else {
			movzerosa = "00";
	 }
 	 if(cycles>9 && cycles<100){
	 		movzerosb = "0";
	 } else if (cycles>99){
	 		movzerosb = "";
	 } else {
			movzerosb = "00";
	 }
	 if((stimNumber+1)>9 && (stimNumber+1)<100) {
	 		movzerosc = "0";
	 } else if ((stimNumber+1)>99){
	 		movzerosc = "";
	 } else {
			movzerosc = "00";
	 }
	 String date = new SimpleDateFormat("yyyy-MM-dd-HH-mm_").format(new Date()); //file date time
	 String filename = ("stream_"+date+"well"+movzerosc+(stimNumber+1)+"cycle"+movzerosb+cycles+"mov"+movzerosa+acqCounter);
	 return filename;
}

//Run and Save Acquisition
int streamAcquisitionAndSave( String guisavepath, String MMfolder, String filename, int intduration)
{

	String currentTime = new SimpleDateFormat("HH:mm:ss.SSS").format(new Date()); 
	displayInfo("Acq. " + acqCounter + " start:            " +currentTime);
   gui.openAcquisition(filename, goodguisavepath, intduration, 1, 1, 1, true, true);
	width = (int) mmc.getImageWidth();
	height = (int) mmc.getImageHeight();
	bytesPerPixel = (int) mmc.getBytesPerPixel();
	bitDepth = (int) mmc.getImageBitDepth();
	gui.initializeAcquisition(filename, width, height, bytesPerPixel, bitDepth);	
	mmc.startSequenceAcquisition(intduration, 0, true);
	frame = 0;
	exposureMs = mmc.getExposure();
	while (mmc.getRemainingImageCount() > 0 || mmc.isSequenceRunning(mmc.getCameraDevice())) {
		if (mmc.getRemainingImageCount() > 0) {
			img = mmc.popNextTaggedImage();
			gui.addImageToAcquisition(filename, frame, 0, 0, 0, img);
			frame++;
	}
	else {
		mmc.sleep(Math.min(0.5 * exposureMs, 20));
		}
	}

	// Close window when finished aquiring
	mmc.stopSequenceAcquisition();
	gui.getAcquisition(filename).promptToSave(false);
	gui.closeAcquisitionWindow(filename);

	// Move file to experiment folder
	String oldfile = guisavepath+"/"+filename+"/MMStack_Pos0.ome.tif";
	String newfile = MMfolder+"/"+filename+".tif";
	print("Moving "+oldfile+" to "+newfile);
	mv(oldfile,newfile); // move file
	oldfolder = new File(guisavepath+"/"+filename);
	if (oldfolder.delete()) {
		print("deleted folder");
	} else {
		print("could not delete folder");
	}
	
	// Update info once acquisition is complete
	acqendtime = System.currentTimeMillis();
	acqduration = acqendtime - firsttime;
	String currentTime = new SimpleDateFormat("HH:mm:ss.SSS").format(new Date()); //file date time
	displayInfo("Acq. " + acqCounter + " end:              " +currentTime);
	
	return (int) acqduration;
}

move(double x, double y, double z)
{
	displayInfo("Moving to                " + (x - startX) + "," + (y - startY) + "," + (z - startZ));
	mmc.setXYPosition(xystage,x,y);
  	//mmc.waitForDevice(xystage);
	//mmc.sleep(1000);
}

gui.clearMessageWindow();
gui.closeAllAcquisitions();

/////////////////////////////////////////////////////////////////////////////////////
// Variables
// 0 indexed in microns
// X, Y and Z
double[] position = {0.0,0.0,0.0}; 
double x0,y0,z0,z1,startX,startY,startZ;

fromfile = readTextInfo("H:/User Defined Acquisition Settings.txt");

// Parse experiment info
guiexposure = fromfile[0];
guibinning = fromfile[1];
guitrigd = fromfile[6];
guitrigp = fromfile[7];
guisavepath = fromfile[8];
guicommand = fromfile[17];

//double guiacqspeed = Double.parseDouble(fromfile[5]);
//int intguiacqspeed = guiacqspeed.intValue();
int intguiacqspeed = 0;

double guitrialduration = Double.parseDouble(fromfile[2]);
int intduration = guitrialduration.intValue();

double guitrials = Double.parseDouble(fromfile[3]);

double guitrialints = Double.parseDouble(fromfile[4]);
int inttrialinterval = guitrialints.intValue();

double guifirstWella = Double.parseDouble(fromfile[9]);
int firstWella = guifirstWella.intValue();

double guifirstWellb = Double.parseDouble(fromfile[10]);
int firstWellb = guifirstWellb.intValue();

double guilastWella = Double.parseDouble(fromfile[11]);
int lastWella = guilastWella.intValue();

double guilastWellb = Double.parseDouble(fromfile[12]);
int lastWellb = guilastWellb.intValue();

double guiplateType = Double.parseDouble(fromfile[13]);
int plateType = guiplateType.intValue();

double guicycleCount = Double.parseDouble(fromfile[14]);
int cycleCount = guicycleCount.intValue();

double guicycleInterval = Double.parseDouble(fromfile[15]);
int cycleInterval = guicycleInterval.intValue();

double guistimulusInterval = Double.parseDouble(fromfile[16]);
int stimulusInterval = guistimulusInterval.intValue();

acq.setFrames(intduration,intguiacqspeed);
TOTAL_TRIALS = guitrials; 	// Total time for acquisition.
ACQ_DELAY = guitrialints;	// Time between acquisitions

//Port for serial commands
global.vport = mmc.getProperty("ArduinoValveControl", "ShowPort");

//sets starting position
xystage = mmc.getXYStageDevice();
startX = mmc.getXPosition(xystage);
startY = mmc.getYPosition(xystage);

// Plate and position list setup
PositionList pl=new PositionList();
gui.setPositionList(pl);
SBSPlate plate = new SBSPlate(plateType,startX,startY);
plate.setFirstWell(firstWella,firstWellb);
plate.setLastWell(lastWella,lastWellb);
numberOfWells = plate.getNumberOfWells();

// if first well is not {1,1}, move to that position
nextString = plate.getPlatePosition(firstWella,firstWellb);
x0 = nextString[0];
y0 = nextString[1];
move(x0,y0,z0);

int index=0;
int countPositions=0;

	// BIG LOOP FOR EACH WELL POSITION
	//-------------------------------------------------------------------------------------------

String guiexperimenttype = "Single-Stimulus";

if(guiexperimenttype.equals("Single-Stimulus")) {
	
		f4 = createInfoWindow("Experiment Progress");
		
		// Create experiment folder
		String guisavepath = "H:\\tmp";
		String ExpDate = new SimpleDateFormat("yyyy-MM-dd-HH-mm").format(new Date()); //file date time
		String MMfolder = guisavepath+"/Experiment_"+ExpDate;
		mkDir(MMfolder);
		cp(settingsFilename, MMfolder+"/Experiment_"+ExpDate+"_settings.txt"); 
		
		for (int cycles = 1; cycles <= cycleCount; cycles++) {
			for (int stimNumber = 0; stimNumber < numberOfWells;) {
				
		  		displayInfo("Starting well:           "+(stimNumber+1));
		  		
		  		// Switch stimuli
				// For each stimulus, run trials
				for (acqCounter=1; acqCounter<= TOTAL_TRIALS; acqCounter++)
				{
		   		// Actions to run if the loop was run more than once.
		   		// Wait for user defined time before running next acquisition.
		   		if (acqCounter > 1) {
		   			// Trial interval [s] = 40 = ACQ_DELAY 
		   			// (40*1000) - (31500-1500) = 10,000
		   			// causes a 30s delay between pulse end and pulse start if 30s video, pulse 5-15s
   					syswait = ((ACQ_DELAY * 1000) - (acqduration - 1500));
      				waitForNextTrial( (int) syswait);
		   		}
		
					// get time at start of cycle
					firsttime = System.currentTimeMillis();
		
		   		// Reset Arduino counter and program
					serialWrite(vport, guicommand);
					//serialWrite(vport, "v2on");
		
					// Set filename and acquire stream
					filename = setFilename( acqCounter, stimNumber, cycles);
					acqduration = streamAcquisitionAndSave(guisavepath, MMfolder, filename, intduration);
		
				} // End - repeated trials per stimulus loop.
		
		      // move the stage to the next well
		      nextString = plate.getNextPlatePosition(); // 0 indexed in microns
		      x0 = nextString[0];
		      y0 = nextString[1];
		      z0 = nextString[2];
		      move(x0,y0,z1);
		      
		      displayInfo("Finished well:           "+(stimNumber+1));
		      displayInfo("Number of wells left:  "+(numberOfWells-(stimNumber+1)));
		      displayInfo("Current cycle:           "+(cycles));
		      displayInfo("Number of cycles left: "+(cycleCount-cycles));
		      
		      stimNumber++;
		      
				// Delay between wells
				waitForNextWell((int) (stimulusInterval*1000));	
				
			} // End - stimulus loop.
		
		displayInfo("Finished cycle:          "+(cycles));
		
		// Move to home position when finished cycle
		move (startX, startY, startZ);
		
		// Delay between cycles
		waitForNextCycle((int) (cycleInterval));	
	
	}  // End loop for multiple cycles
	
	displayInfo("***finished acquisition***");
	
}